<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VSL74PME4G"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-VSL74PME4G');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Personal website of Gar">
    <meta name="keywords" content="gar, garlol, portfolio, art, music, creative projects, portraits">
    <title>gar.lol</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Assistant&family=Libre+Baskerville&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Assistant', sans-serif;
            color: #222;
            background-color: #fff;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1; /* Put the canvas behind other content */
        }

        .content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2.3rem;
            font-family: 'Pixelify Sans', sans-serif;
            font-size: 1.2rem;
        }

            .content nav {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }

        .logo-container {
            width: 120px;
            height: 120px;
            background: black;
            border-radius: 50%;
            border: 1px solid #bbb;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

            .logo-container img {
                width: 88px;
                height: 88px;
                object-fit: contain;
            }

        .hover-underline a {
            position: relative;
            color: #ddd;
            text-decoration: none;
            transition: .3s ease;
        }

            .hover-underline a::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 2px;
                background-color: currentColor;
                transform: scaleX(0);
                transform-origin: right;
                transition: transform 0.25s ease;
            }

            .hover-underline a:hover::after {
                transform: scaleX(1);
                transform-origin: left;
            }

        /* Navigation styles */
        .nav-links {
            display: flex;
            list-style: none;
            gap: .9rem;
            align-items: center;
        }

            .nav-links a {
                padding: .2rem;
            }

            .nav-links li:not(:last-child)::after {
                margin-left: .5rem;
            }

        /* Social links styles */
        .social-links {
            list-style: none;
            display: flex;
            gap: 1.4rem;
        }

        /* Adjusted format for mobile */
        @media (max-width: 768px) {
            .nav-links {
                display: block;
            }

            .nav-links li:not(:last-child) {
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>

    <div class="content">
        <div class="logo-container">
            <img src="moonface_inverted.png" class="logo" alt="Moon face logo" width="88" height="88">
        </div>

        <nav style="display: none">
            <ul class="nav-links hover-underline">
                <li><a href="#" aria-label="View writings section">Writings</a></li>
                <li><a href="#" aria-label="View music section">Music</a></li>
                <li><a href="#" aria-label="View art section">Art</a></li>
                <li><a href="#" aria-label="View projects section">Projects</a></li>
            </ul>
        </nav>

        <div class="social-links hover-underline">
            <a href="https://github.com/rothos" target="_blank" rel="noopener noreferrer" aria-label="Visit GitHub profile">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
            </a>
            <a href="https://twitter.com/moonboi_" target="_blank" rel="noopener noreferrer" aria-label="Visit Twitter profile">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"/></svg>
            </a>
            <a href="https://instagram.com/rothosphere" target="_blank" rel="noopener noreferrer" aria-label="Visit Instagram profile">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect width="20" height="20" x="2" y="2" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/></svg>
            </a>
            <a href="mailto:&#104;&#114;&#111;&#116;&#104;&#103;&#97;&#114;&#114;&#114;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" class="email-link" aria-label="Send email">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect width="20" height="16" x="2" y="4" rx="2"/><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"/></svg>
            </a>
        </div>
    </div>

    <script>
    function deepMerge(target, source) {
        for (const key in source) {
            if (source[key] instanceof Object && key in target) {
                Object.assign(source[key], deepMerge(target[key], source[key]));
            }
        }
        return { ...target, ...source };
    }

    // Configuration object
    const defaultConfig = {
        animation: {
            speed: 0.03,
            animationFPS: 60
        },
        spiral: {
            tightness: 180,
            spinSpeed: -0.08,
            wobbleSpeed: 0.24,
            wobbleAmplitude: 6.0,
            radialWave: {
                amplitude: 0.1,
                length: 13.5,
                speed: 0.8
            }
        },
        rendering: {
            spiralPixelSize: 1,
            noisePixelSize: 1
        },
        noise: {
            intensity: 5,
            updateFraction: 0.25,
            tileSize: 500,
            noiseFPS: 15
        },
        color: {
            saturation: 70,
            lightness: 80
        }
    };


    const mobileConfig = deepMerge(defaultConfig, {
        spiral: {
            tightness: 150,
            radialWave: {
                amplitude: 0.08,
                length: 10
            }
        },
        noise: {
            intensity: 3.75
        }
    });

    // Shader sources
    const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        
        void main() {
            v_texCoord = (a_position + 1.0) * 0.5;
            gl_Position = vec4(a_position, 0, 1);
        }
    `;

    const fragmentShaderSource = `
        precision highp float;
        varying vec2 v_texCoord;
        
        float PI = 3.14159265358979;

        uniform vec2 u_center;
        uniform float u_time;
        uniform float u_animationFPS;
        uniform float u_spiralTightness;
        uniform float u_spiralPixelSize;
        uniform float u_spiralSpinSpeed;
        uniform float u_spiralWobbleSpeed;
        uniform float u_spiralWobbleAmplitude;
        uniform float u_radialWaveAmplitude;
        uniform float u_radialWaveLength;
        uniform float u_radialWaveSpeed;
        uniform float u_saturation;
        uniform float u_lightness;
        uniform float u_noiseFPS;
        uniform float u_noisePixelSize;
        uniform float u_noiseTileSize;
        uniform float u_noiseIntensity;
        uniform float u_noiseUpdateFraction;
        
        float hue2rgb(float p, float q, float t) {
            if(t < 0.0) t += 1.0;
            if(t > 1.0) t -= 1.0;
            if(t < 1.0/6.0) return p + (q - p) * 6.0 * t;
            if(t < 1.0/2.0) return q;
            if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
            return p;
        }
        
        vec3 hsl2rgb(float h, float s, float l) {
            vec3 rgb;
            
            if(s == 0.0) {
                rgb = vec3(l, l, l);
            } else {
                float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
                float p = 2.0 * l - q;
                rgb.r = hue2rgb(p, q, h + 1.0/3.0);
                rgb.g = hue2rgb(p, q, h);
                rgb.b = hue2rgb(p, q, h - 1.0/3.0);
            }
            
            return rgb;
        }

        // Utility function for uniform random numbers
        float random(vec2 st, float time) {
            vec3 p3 = fract(vec3(st.xy, time) * vec3(12.9898,78.233,45.164));
            p3 += dot(p3, p3.yzx + 19.19);
            return fract((p3.x + p3.y) * p3.z);
        }

        // Box-Muller transform to get gaussian distribution
        float gaussianRandom(vec2 coord, float time) {
            // Get two independent random values
            float u1 = random(coord, time);
            float u2 = random(coord + vec2(1.0), time);
            
            // Box-Muller transform
            float r = sqrt(-2.0 * log(u1));
            float theta = 2.0 * PI * u2;
            
            // The clamp is necessary to prevent the tails of the Gaussian
            // causing some pixels to be painted white or black.
            return clamp(r * cos(theta), -3.0, 3.0);
        }

        float getNoiseValue(vec2 coord, float time) {
            // Calculate which noise cell we're in
            vec2 noiseCoord = floor(coord / u_noisePixelSize);
            
            // Calculate how many noise cells per tile
            float cellsPerTile = u_noiseTileSize;
            
            // Get coordinates within a tile (in noise cell units)
            vec2 tileCoord = mod(noiseCoord, cellsPerTile);
            
            // Quantize time to frames
            float frameTime = floor(time * u_noiseFPS);
            
            // Generate a consistent random value for this pixel
            float pixelRandom = random(tileCoord, 0.0);
            
            // Calculate when this pixel should last have updated
            // This creates bands of pixels that update at different times
            float updateGroup = floor(pixelRandom / u_noiseUpdateFraction);
            float lastUpdateFrame = frameTime - mod(frameTime - updateGroup, 1.0/u_noiseUpdateFraction);
            
            return gaussianRandom(tileCoord, lastUpdateFrame) * u_noiseIntensity/255.;
        }

        void waves(vec2 pos, float t, float numWaves, out float height, out vec2 gradient) {
            height = 0.0;
            gradient = vec2(0.0);
            
            for (float i = 0.0; i < 1000.0; i += 1.0) {
                if (i >= numWaves) break;
                float angle = fract(sin(i*1232.399963)) * 6.28318530718;
                vec2 dir = vec2(cos(angle), sin(angle));
                float rand = fract(sin(i*3243.49301));
                
                float amp = 4.0 * pow(0.86, i) + rand;
                float freq = pow(1.13, i) * 5.0 / (1.0 + rand);
                
                float wave = dot(pos, dir) * freq + rand + t;
                float s = sin(wave);
                float c = cos(wave);
                
                height += amp * s;
                gradient += amp * freq * dir * c;
            }
            
            gradient *= 0.001;
        }

        void main() {
            // Pixelate coordinates for spiral
            vec2 pixelCoord = floor(gl_FragCoord.xy / u_spiralPixelSize) * u_spiralPixelSize + u_spiralPixelSize/2.0;
            vec2 pos = pixelCoord - u_center;

            float darkFactor = 3.;

            vec2 uv = pos/450.;
            vec2 uvn = 2.0 * uv;
            float t = u_time/2.5;
            
            float h;
            vec2 grad;
            waves(uvn, t, 22.0, h, grad);
            
            vec2 distorted_uv = uv + grad;
            float d = length(distorted_uv);
            float angle2 = -atan(distorted_uv.y, distorted_uv.x);
            
            d = sin(d*12.0 - t + angle2/2.0)/12.0;
            // float lightness = 1.2 - smoothstep(0.0, 0.004, abs(d));
            float lightness = 0.16 + pow(1. - smoothstep(0.0, .02, abs(d)), .01);




            float distance = length(pos);
            float angle = -atan(pos.y, pos.x);

            // Quantize time for animation
            float quantizedTime = floor(u_time * u_animationFPS) / u_animationFPS;

            // Calculate spiral value
            float safeDistance = max(distance, 0.1);
            float spiralValue = angle + 
                (distance/u_spiralTightness) * (
                    // This line determines the "spin wobble" -- 0.5 is the wobble phase shift
                    0.5 + u_spiralWobbleAmplitude * sin(4.0 - u_spiralWobbleSpeed * quantizedTime) / sqrt(safeDistance) +
                    u_radialWaveAmplitude/sqrt(distance)*22.0 * sin(distance/u_radialWaveLength - quantizedTime*u_radialWaveSpeed)
                ) + 
                quantizedTime * u_spiralSpinSpeed;
            
            spiralValue = mod(mod(spiralValue / (2.0 * PI), 1.0) + 1.0, 1.0);
            
            vec3 color = hsl2rgb(spiralValue, u_saturation/darkFactor, lightness/darkFactor);

            float noiseValue = getNoiseValue(gl_FragCoord.xy, quantizedTime);
            color = color + vec3(noiseValue);
            color = clamp(color, 0.0, 1.0);

            gl_FragColor = vec4(color, 1.0);
        }
    `;

    // WebGL setup and state management
    let gl;
    let program;
    let time = 0;
    let lastFrameTime = 0;
    let animationFrameId = null;

    function getCurrentConfig() {
        return window.innerWidth <= 768 ? mobileConfig : defaultConfig;
    }

    function initWebGL() {
        const canvas = document.getElementById('bgCanvas');
        gl = canvas.getContext('webgl');
        if (!gl) {
            console.error('WebGL not supported');
            return;
        }
        
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);
        
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);
        
        program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        
        const vertices = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        const uniforms = [
            'u_time', 'u_center', 'u_spiralTightness',
            'u_spiralSpinSpeed', 'u_spiralWobbleSpeed', 'u_spiralWobbleAmplitude',
            'u_radialWaveAmplitude', 'u_radialWaveLength', 'u_radialWaveSpeed',
            'u_animationFPS',
            'u_spiralPixelSize', 'u_saturation', 'u_lightness',
            'u_noisePixelSize', 'u_noiseTileSize',
            'u_noiseIntensity', 'u_noiseUpdateFraction', 'u_noiseFPS'
        ];
        
        program.uniformLocations = {};
        for (const uniform of uniforms) {
            const location = gl.getUniformLocation(program, uniform);
            program.uniformLocations[uniform] = location;
        }
    }

    function resizeCanvas() {
        const canvas = document.getElementById('bgCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function render(currentTime) {
        if (!program || !gl) {
            console.error('WebGL not properly initialized');
            return;
        }
        
        const config = getCurrentConfig();
        
        const logoElement = document.querySelector('.logo-container');
        const logoRect = logoElement.getBoundingClientRect();
        const canvas = document.getElementById('bgCanvas');
        const canvasRect = canvas.getBoundingClientRect();
        
        const centerX = logoRect.left - canvasRect.left + (logoRect.width / 2);
        const centerY = logoRect.top - canvasRect.top + (logoRect.height / 2);
        
        // Make sure we're using our program
        gl.useProgram(program);
        
        // Update uniforms using stored locations
        gl.uniform1f(program.uniformLocations['u_time'], time);
        gl.uniform2f(program.uniformLocations['u_center'], centerX, window.innerHeight - centerY);
        gl.uniform1f(program.uniformLocations['u_animationFPS'], config.animation.animationFPS);
        gl.uniform1f(program.uniformLocations['u_spiralTightness'], config.spiral.tightness);
        gl.uniform1f(program.uniformLocations['u_spiralSpinSpeed'], config.spiral.spinSpeed);
        gl.uniform1f(program.uniformLocations['u_spiralWobbleSpeed'], config.spiral.wobbleSpeed);
        gl.uniform1f(program.uniformLocations['u_spiralWobbleAmplitude'], config.spiral.wobbleAmplitude);
        gl.uniform1f(program.uniformLocations['u_radialWaveAmplitude'], config.spiral.radialWave.amplitude);
        gl.uniform1f(program.uniformLocations['u_radialWaveLength'], config.spiral.radialWave.length);
        gl.uniform1f(program.uniformLocations['u_radialWaveSpeed'], config.spiral.radialWave.speed);
        gl.uniform1f(program.uniformLocations['u_spiralPixelSize'], config.rendering.spiralPixelSize);
        gl.uniform1f(program.uniformLocations['u_saturation'], config.color.saturation / 100);
        gl.uniform1f(program.uniformLocations['u_lightness'], config.color.lightness / 100);
        gl.uniform1f(program.uniformLocations['u_noiseFPS'], config.noise.noiseFPS);
        gl.uniform1f(program.uniformLocations['u_noisePixelSize'], config.rendering.noisePixelSize);
        gl.uniform1f(program.uniformLocations['u_noiseTileSize'], config.noise.tileSize);
        gl.uniform1f(program.uniformLocations['u_noiseIntensity'], config.noise.intensity);
        gl.uniform1f(program.uniformLocations['u_noiseUpdateFraction'], config.noise.updateFraction);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        time += config.animation.speed;

        // requestAnimationFrame(render);
        animationFrameId = requestAnimationFrame(render);
    }

    // Update the resize event handler
    window.addEventListener('resize', () => {
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
        }
        resizeCanvas();
        animationFrameId = requestAnimationFrame(render);
    });

    // Force immediate render after scroll to update logo position
    window.addEventListener('scroll', () => {
        if (animationFrameId !== null) {
            cancelAnimationFrame(animationFrameId);
        }
        animationFrameId = requestAnimationFrame(render);
    });

    // Update the load event handler
    window.addEventListener('load', () => {
        initWebGL();
        resizeCanvas();
        animationFrameId = requestAnimationFrame(render);
    });
    </script>

</body>
</html>
