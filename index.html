<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VSL74PME4G"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-VSL74PME4G');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Personal website of Gar">
    <meta name="keywords" content="gar, garlol, portfolio, art, music, creative projects, portraits">
    <title>gar.lol</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Assistant&family=Libre+Baskerville&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Assistant', sans-serif;
            color: #222;
            background-color: #fff;
            position: relative;
            overflow: hidden;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1; /* Put the canvas behind other content */
        }

        .content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2.3rem;
            font-family: 'Pixelify Sans', serif;
            font-size: 1.2rem;
        }

            .content nav {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 2rem;
            }

        .logo-container {
            width: 120px;
            height: 120px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

            .logo-container img {
                width: 88px;
                height: 88px;
                object-fit: contain;
            }

        .hover-underline a {
            position: relative;
            color: #333;
            text-decoration: none;
            transition: .3s ease;
        }

            .hover-underline a::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 2px;
                background-color: currentColor;
                transform: scaleX(0);
                transform-origin: right;
                transition: transform 0.25s ease;
            }

            .hover-underline a:hover::after {
                transform: scaleX(1);
                transform-origin: left;
            }

        /* Navigation styles */
        .nav-links {
            list-style: none;
            display: flex;
            gap: .9rem;
            align-items: center;
        }

            .nav-links a {
                padding: .2rem;
            }

            .nav-links li:not(:last-child)::after {
                margin-left: .5rem;
            }

        /* Social links styles */
        .social-links {
            list-style: none;
            display: flex;
            gap: 1.4rem;
        }

        /* Adjusted format for mobile */
        @media (max-width: 768px) {
            .nav-links {
                display: block;
            }

            .nav-links li:not(:last-child) {
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>

    <div class="content">
        <div class="logo-container">
            <img src="moonface.png" class="logo" alt="Moon face logo" width="88" height="88">
        </div>

        <nav>
            <ul class="nav-links hover-underline">
                <li><a href="#" aria-label="View writings section">Writings</a></li>
                <li><a href="#" aria-label="View music section">Music</a></li>
                <li><a href="#" aria-label="View art section">Art</a></li>
                <li><a href="#" aria-label="View projects section">Projects</a></li>
            </ul>
        </nav>

        <div class="social-links hover-underline">
            <a href="https://github.com/rothos" target="_blank" rel="noopener noreferrer" aria-label="Visit GitHub profile">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"/><path d="M9 18c-4.51 2-5-2-7-2"/></svg>
            </a>
            <a href="https://twitter.com/moonboi_" target="_blank" rel="noopener noreferrer" aria-label="Visit Twitter profile">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"/></svg>
            </a>
            <a href="https://instagram.com/rothosphere" target="_blank" rel="noopener noreferrer" aria-label="Visit Instagram profile">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect width="20" height="20" x="2" y="2" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"/></svg>
            </a>
            <a href="mailto:&#104;&#114;&#111;&#116;&#104;&#103;&#97;&#114;&#114;&#114;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" class="email-link" aria-label="Send email">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect width="20" height="16" x="2" y="4" rx="2"/><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"/></svg>
            </a>
        </div>
    </div>

    <script>
    // Configuration object
    const defaultConfig = {
        animation: {
            speed: 0.03,
            animationFPS: 60
        },
        spiral: {
            tightness: 180,
            spinSpeed: -0.08,
            wobbleFreq: 0.24,
            wobbleAmplitude: 6.0,
            radialWave: {
                amplitude: 0.1,
                length: 13.5,
                speed: 0.8
            }
        },
        rendering: {
            spiralPixelSize: 4,
            noisePixelSize: 1
        },
        noise: {
            intensity: 5,
            updateFraction: 0.25,
            tileSize: 200,
            noiseFPS: 15
        },
        color: {
            saturation: 70,
            lightness: 80
        }
    };

    const mobileConfig = {
        ...defaultConfig,
        spiral: {
            ...defaultConfig.spiral,
            tightness: 150,
            radialWave: {
                ...defaultConfig.spiral.radialWave,
                amplitude: .12,
                length: 10
            }
        }
    };

    // Shader sources
    const vertexShaderSource = `
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        
        void main() {
            v_texCoord = (a_position + 1.0) * 0.5;
            gl_Position = vec4(a_position, 0, 1);
        }
    `;

    const fragmentShaderSource = `
        precision highp float;
        varying vec2 v_texCoord;
        
        float PI = 3.14159265358979;

        uniform float u_time;
        uniform float u_animSpeed;
        uniform vec2 u_center;
        uniform float u_spiralTightness;
        uniform float u_spiralPixelSize;
        uniform float u_spiralSpinSpeed;
        uniform float u_spiralWobbleFreq;
        uniform float u_spiralWobbleAmplitude;
        uniform float u_waveAmplitude;
        uniform float u_waveLength;
        uniform float u_waveSpeed;
        uniform float u_saturation;
        uniform float u_lightness;
        uniform float u_noisePixelSize;
        uniform float u_noiseTileSize;
        uniform float u_noiseIntensity;
        uniform float u_noiseUpdateFraction;
        uniform float u_noiseFPS;
        
        float hue2rgb(float p, float q, float t) {
            if(t < 0.0) t += 1.0;
            if(t > 1.0) t -= 1.0;
            if(t < 1.0/6.0) return p + (q - p) * 6.0 * t;
            if(t < 1.0/2.0) return q;
            if(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
            return p;
        }
        
        vec3 hsl2rgb(float h, float s, float l) {
            vec3 rgb;
            
            if(s == 0.0) {
                rgb = vec3(l, l, l);
            } else {
                float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
                float p = 2.0 * l - q;
                rgb.r = hue2rgb(p, q, h + 1.0/3.0);
                rgb.g = hue2rgb(p, q, h);
                rgb.b = hue2rgb(p, q, h - 1.0/3.0);
            }
            
            return rgb;
        }

        // Utility function for uniform random numbers
        float random(vec2 st, float time) {
            vec3 p3 = fract(vec3(st.xy, time) * vec3(12.9898,78.233,45.164));
            p3 += dot(p3, p3.yzx + 19.19);
            return fract((p3.x + p3.y) * p3.z);
        }

        // Box-Muller transform to get gaussian distribution
        float gaussianRandom(vec2 coord, float time) {
            // Get two independent random values
            float u1 = random(coord, time);
            float u2 = random(coord + vec2(1.0), time);
            
            // Box-Muller transform
            float r = sqrt(-2.0 * log(u1));
            float theta = 2.0 * PI * u2;
            
            // The clamp is necessary to prevent the tails of the Gaussian
            // causing some pixels to be painted white or black.
            return clamp(r * cos(theta), -3.0, 3.0);
        }

        float getNoiseValue(vec2 coord, float time) {
            // Calculate which noise cell we're in
            vec2 noiseCoord = floor(coord / u_noisePixelSize);
            
            // Calculate how many noise cells per tile
            float cellsPerTile = u_noiseTileSize;
            
            // Get coordinates within a tile (in noise cell units)
            vec2 tileCoord = mod(noiseCoord, cellsPerTile);
            
            // Quantize time to frames
            float frameTime = floor(time * u_noiseFPS);
            
            // Generate a consistent random value for this pixel
            float pixelRandom = random(tileCoord, 0.0);
            
            // Calculate when this pixel should last have updated
            // This creates bands of pixels that update at different times
            float updateGroup = floor(pixelRandom / u_noiseUpdateFraction);
            float lastUpdateFrame = frameTime - mod(frameTime - updateGroup, 1.0/u_noiseUpdateFraction);
            
            return gaussianRandom(tileCoord, lastUpdateFrame) * u_noiseIntensity/255.;
        }

        void main() {
            // Pixelate coordinates for spiral
            vec2 pixelCoord = floor(gl_FragCoord.xy / u_spiralPixelSize) * u_spiralPixelSize + u_spiralPixelSize/2.0;
            vec2 pos = pixelCoord - u_center;
            
            float distance = length(pos);
            float angle = -atan(pos.y, pos.x);
            
            // Calculate spiral value
            float safeDistance = max(distance, 0.1);
            float spiralValue = angle + 
                (distance/u_spiralTightness) * (
                    // This line determines the "spin wobble" -- 0.5 is the wobble phase shift
                    0.5 + u_spiralWobbleAmplitude * sin(4.0 - u_spiralWobbleFreq * u_time) / sqrt(safeDistance) +
                    u_waveAmplitude * sin(distance/u_waveLength - u_time*u_waveSpeed)
                ) + 
                u_time * u_spiralSpinSpeed;
            
            spiralValue = mod(mod(spiralValue / (2.0 * PI), 1.0) + 1.0, 1.0);
            
            vec3 color = hsl2rgb(spiralValue, u_saturation, u_lightness);

            float noiseValue = getNoiseValue(gl_FragCoord.xy, u_time);
            color = color + vec3(noiseValue);
            color = clamp(color, 0.0, 1.0);

            gl_FragColor = vec4(color, 1.0);
        }
    `;

    // WebGL setup and state management
    let gl;
    let program;
    let time = 0;
    let lastFrameTime = 0;

    function getCurrentConfig() {
        return window.innerWidth <= 768 ? mobileConfig : defaultConfig;
    }

    function initWebGL() {
        const canvas = document.getElementById('bgCanvas');
        gl = canvas.getContext('webgl');
        if (!gl) {
            console.error('WebGL not supported');
            return;
        }
        
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);
        
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);
        
        program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        
        const vertices = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        const uniforms = [
            'u_time', 'u_center', 'u_spiralTightness',
            'u_spiralSpinSpeed', 'u_spiralWobbleFreq', 'u_spiralWobbleAmplitude',
            'u_waveAmplitude', 'u_waveLength', 'u_waveSpeed', 'u_animSpeed',
            'u_spiralPixelSize', 'u_saturation', 'u_lightness',
            'u_noisePixelSize', 'u_noiseTileSize',
            'u_noiseIntensity', 'u_noiseUpdateFraction', 'u_noiseFPS'
        ];
        
        program.uniformLocations = {};
        for (const uniform of uniforms) {
            const location = gl.getUniformLocation(program, uniform);
            program.uniformLocations[uniform] = location;
        }
    }

    function resizeCanvas() {
        const canvas = document.getElementById('bgCanvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function render(currentTime) {
        if (!program || !gl) {
            console.error('WebGL not properly initialized');
            return;
        }
        
        const config = getCurrentConfig();
        
        const deltaTime = (currentTime - lastFrameTime) / 1000;
        lastFrameTime = currentTime;
        
        if (deltaTime > 1/15) {
            requestAnimationFrame(render);
            return;
        }

        const timeIncrement = config.animation.speed * (deltaTime * config.animation.animationFPS);
        
        const logoElement = document.querySelector('.logo-container');
        const logoRect = logoElement.getBoundingClientRect();
        const canvas = document.getElementById('bgCanvas');
        const canvasRect = canvas.getBoundingClientRect();
        
        const centerX = logoRect.left - canvasRect.left + (logoRect.width / 2);
        const centerY = logoRect.top - canvasRect.top + (logoRect.height / 2);
        
        // Make sure we're using our program
        gl.useProgram(program);
        
        // Update uniforms using stored locations
        gl.uniform1f(program.uniformLocations['u_time'], time);
        gl.uniform2f(program.uniformLocations['u_center'], centerX, window.innerHeight - centerY);
        gl.uniform1f(program.uniformLocations['u_spiralTightness'], config.spiral.tightness);
        gl.uniform1f(program.uniformLocations['u_spiralSpinSpeed'], config.spiral.spinSpeed);
        gl.uniform1f(program.uniformLocations['u_spiralWobbleFreq'], config.spiral.wobbleFreq);
        gl.uniform1f(program.uniformLocations['u_spiralWobbleAmplitude'], config.spiral.wobbleAmplitude);
        gl.uniform1f(program.uniformLocations['u_waveAmplitude'], config.spiral.radialWave.amplitude);
        gl.uniform1f(program.uniformLocations['u_waveLength'], config.spiral.radialWave.length);
        gl.uniform1f(program.uniformLocations['u_waveSpeed'], config.spiral.radialWave.speed);
        gl.uniform1f(program.uniformLocations['u_animSpeed'], config.animation.speed);
        gl.uniform1f(program.uniformLocations['u_spiralPixelSize'], config.rendering.spiralPixelSize);
        gl.uniform1f(program.uniformLocations['u_saturation'], config.color.saturation / 100);
        gl.uniform1f(program.uniformLocations['u_lightness'], config.color.lightness / 100);
        gl.uniform1f(program.uniformLocations['u_noisePixelSize'], config.rendering.noisePixelSize);
        gl.uniform1f(program.uniformLocations['u_noiseTileSize'], config.noise.tileSize);
        gl.uniform1f(program.uniformLocations['u_noiseIntensity'], config.noise.intensity);
        gl.uniform1f(program.uniformLocations['u_noiseUpdateFraction'], config.noise.updateFraction);
        gl.uniform1f(program.uniformLocations['u_noiseFPS'], config.noise.noiseFPS);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        
        time += timeIncrement;
        requestAnimationFrame(render);
    }

    // Initialize and start animation
    window.addEventListener('resize', () => {
        resizeCanvas();
        // Force immediate render after resize to prevent flicker
        render(performance.now());
    });

    window.addEventListener('scroll', () => {
        // Force immediate render after scroll to update logo position
        render(performance.now());
    });

    window.addEventListener('load', () => {
        initWebGL();
        resizeCanvas();
        requestAnimationFrame(render);
    });
    </script>

</body>
</html>
